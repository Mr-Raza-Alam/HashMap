import java.util.*;
public class ImpleOfHashMap {
 // task :- to implement all hashmap operations with O(1)
 static class hashMap<K,V>{// here <K,V> is called genenric -> it is a parameterism type 
    private class Node{ // a node exit in each of bucket of ll in an array of type ll
        K key;
        V val;
    public Node(K key,V value){
        this.key = key;
        this.val = value;
      }        
    }
  private int n,N;// length of ll,size of array of ll  
  //Here as we declare an array like int arr[],where int is data-type similarly
  private LinkedList<Node> buckets[];// N = no.of nodes in an array of ll & here,bucket[] is linked-list-type which contain nodes of(k,v)
 @SuppressWarnings("unchecked") //in some java version,it is to supress the warning generated by this statement LinkedList<T> is requrie otherwise it throw an error
  public hashMap(){
    this.N = 4;
    this.buckets = new LinkedList[4];// declaration of array bucket of  size 4
    for(int i = 0; i<4; i++){// initialization of buckets array
        this.buckets[i] = new LinkedList<>();
     }
  }
  private int hashFunction(K k){
    int hc = k.hashCode();// return a integer hash-code
    //e.g a hashcode like 2354322,-5894382
    return Math.abs(hc)%N;// here it return bi's value b/w 0 to size-1
  }

  @SuppressWarnings("unchecked")
private void rehash(){
    LinkedList<Node> oldBuck[] = buckets;
    buckets = new LinkedList[N*2];
    N = N*2;// array of ll become double 
    for(int i = 0; i<buckets.length; i++){
        buckets[i]  = new LinkedList<>();
    }
// and now add all values from old buck to new bucket of size double
   for(int j = 0; j<oldBuck.length; j++){
    LinkedList<Node> ll = oldBuck[j];// create a ll on each idx of new buckets
    while(!ll.isEmpty()){
     Node node = ll.remove();// remove all old bucket
     put(node.key,node.val);// and then add in new bucket
      }
   }
  }
  private int searchInLL(K key,int bi){
    LinkedList<Node> ll = buckets[bi];// ll is avialble on bi 
    for(int i = 0; i<ll.size(); i++){
      Node node = ll.get(i);
      if(node.key == key){
          return i;// this will be data idx where key is already exit
        }
      }
     return -1;// in case , when there is no such key is exit in a ll at bi(bucket idx)
    }
    // put(Key,Value) 
  public void put(K key,V val){// O(1)
    // step-1   
    int bi = hashFunction(key);//  0=<bi exit <=size-1
    // step-2 
    int di = searchInLL(key,bi);// return a valid data-idx if(key) is exit otherwise return -1 i.e means no such key is exit
    if(di != -1){// this mins that key exit
     // only key-value updatation is required
     Node node = buckets[bi].get(di);
     node.val = val;
    } else{// create a new node and add it in the ll on bi
    buckets[bi].add(new Node(key, val));
    n++;
    }
   // now check for reHashing cond.
    double lamda = (double)n/N;
    if(lamda > 2.0){// 2.0 is threshold value
    rehash();
     }
   }
// containsKey(key) O(1)
 public boolean containsKey(K key){
    int bi = hashFunction(key);
    int di = searchInLL(key, bi);
    if(di != -1) return true;
    else return false;
  }

  // get(key) 
  V get(K key){
    int bi = hashFunction(key);
    int di = searchInLL(key, bi);
    if(di != -1){
        Node node = buckets[bi].get(di);
        return node.val;
    } else return null;
  }
// remove(key) --> O(lamda) but lamda <= threshold value therefore its TC = O(1)
V remove(K key){
    int bi = hashFunction(key);
    int di = searchInLL(key, bi);
    if(di != -1){
        Node node = buckets[bi].remove(di);
        n--;// a exiting node has removed
        return node.val;
    } else return null;
  }
// ketSet();
public ArrayList<K> keySet(){
   ArrayList<K> keysList = new ArrayList<>();
   for(int i = 0; i<buckets.length; i++){
    LinkedList<Node> ll = buckets[i];
    for(Node node : ll){
        keysList.add(node.key);
     }
   }
    return keysList;
  }
// isEmpty()
public boolean isEmpty(){
    return n == 0;// if n = 0 then hashmap donot exit so,return true otherwise false
}

}   
 
 public static void main(String[] args) {
   hashMap<String,Integer> hm = new hashMap<>();
   // create a hashmap for hotel menu
   hm.put("Tea",5);
   hm.put("Samosa",6);
   hm.put("lassi",15);
   hm.put("Iddli",20);
   hm.put("Momo",30);
   hm.put("Burger",25);
   hm.put("Rasmalai",12);
   System.out.println("Ramsung-Menu contains food-items are :- ");
   ArrayList<String> Fooditem = hm.keySet();
 for(String k : Fooditem){
    System.out.println(k);
 }
 System.out.println("Price of Samosa = "+hm.get("Samosa"));
 System.out.println("Momo is exit or not ?\nAns = "+hm.containsKey("Momo"));


 }
 
}
